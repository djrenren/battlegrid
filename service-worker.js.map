{"version":3,"file":"service-worker.js","sources":["../src/net/resources/service-worker.ts"],"sourcesContent":["/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"es2020\" />\n/// <reference lib=\"WebWorker\" />\n\nimport { CachedKeyDecoder } from \"@msgpack/msgpack/dist/CachedKeyDecoder\";\nimport { timeout } from \"../../util/promises\";\nimport { ResourceMessage } from \"./service-worker-protocol\";\n\ntype ResourceId = string;\n\nconst sw = self as ServiceWorkerGlobalScope & typeof globalThis;\n\nlet pending = new Map<\n  ResourceId,\n  {\n    resolve: () => void;\n    reject: (err: any) => void;\n    promise: Promise<void>;\n  }\n>();\n\nlet cache: Cache;\n\nsw.addEventListener(\"install\", (ev) => {\n  console.log(\"installing\");\n});\n\nsw.addEventListener(\"message\", (ev: ExtendableMessageEvent) => {\n  ev.waitUntil(\n    (async () => {\n      let data = ev.data as ResourceMessage;\n      switch (data.type) {\n        case \"found\":\n          pending.get(data.id)?.resolve();\n          break;\n        case \"notfound\":\n          pending.get(data.id)?.reject(data.error);\n      }\n    })()\n  );\n});\n\nsw.addEventListener(\"activate\", (ev) => {\n  console.log(\"activate\");\n  ev.waitUntil(\n    (async () => {\n      cache = await caches.open(\"resources\");\n      await sw.clients.claim();\n      console.log(\"claimed clients\");\n    })()\n  );\n});\n\nfunction which_resource(url: string): ResourceId | null {\n  let segs = new URL(url).pathname.split(\"/\");\n  if (segs.length !== 3 && segs[1] != \"resources\") {\n    return null;\n  }\n\n  return segs[2] as ResourceId;\n}\n\nasync function fetch_resource(ev: FetchEvent): Promise<Response> {\n  const request = ev.request;\n  const resource = which_resource(request.url);\n  console.log(\"TRYING TO FETCH\", request.url, resource);\n  if (!resource) {\n    return new Response(null, {\n      status: 404,\n      statusText: \"Not found\",\n    });\n  }\n\n  let promise = pending.get(resource)?.promise;\n\n  // request is not pending\n  if (!promise) {\n    console.log(\"Request is not pending\");\n    let resolve: () => void;\n    let reject: (err: any) => void;\n    promise = new Promise<void>((a, b) => {\n      resolve = a;\n      reject = b;\n    });\n\n    pending.set(resource, {\n      resolve: () => {\n        console.log(\"RESOLVE\");\n        pending.delete(resource);\n        resolve();\n      },\n      reject: (err: any) => {\n        console.log(\"REJECT\");\n        pending.delete(resource);\n        reject(err);\n      },\n      promise,\n    });\n\n    let cached = await caches.match(ev.request);\n    if (cached) {\n      console.log(\"request is cached\");\n      resolve!();\n      return cached;\n    } else {\n      console.log(\"request is not cached\");\n      const c = await sw.clients.get(ev.clientId);\n      if (!c) {\n        reject!(\"client does not exist\");\n      } else {\n        console.log(\"forwarding request to client\");\n        c.postMessage({ id: resource });\n      }\n    }\n  }\n\n  let res = await promise.then(() => caches.match(ev.request)).catch((err) => new Response(err, { status: 500, statusText: \"Internal Error\" }));\n\n  return (\n    res ||\n    new Response(null, {\n      status: 404,\n      statusText: \"Not found\",\n    })\n  );\n}\n\nsw.addEventListener(\"fetch\", (ev) => {\n  let url = new URL(ev.request.url);\n  if (!url.pathname.startsWith(\"/resources/\")) {\n    return false;\n  }\n  ev.respondWith(\n    (async () => {\n      console.log(ev.request.headers);\n      console.log(\"RESPONDING\");\n      return fetch_resource(ev);\n    })()\n  );\n});\n"],"names":["sw","self","pending","Map","async","fetch_resource","ev","request","resource","url","segs","URL","pathname","split","length","which_resource","console","log","Response","status","statusText","promise","get","resolve","reject","Promise","a","b","set","delete","err","cached","caches","match","c","clients","clientId","postMessage","id","then","catch","addEventListener","waitUntil","data","type","error","open","claim","startsWith","respondWith","headers"],"mappings":"AAUA,MAAMA,EAAKC,KAEX,IAAIC,EAAU,IAAIC,IAkDlBC,eAAeC,EAAeC,GAC5B,MAAMC,EAAUD,EAAGC,QACbC,EAXR,SAAwBC,GACtB,IAAIC,EAAO,IAAIC,IAAIF,GAAKG,SAASC,MAAM,KACvC,OAAoB,IAAhBH,EAAKI,QAA2B,aAAXJ,EAAK,GACrB,KAGFA,EAAK,GAKKK,CAAeR,EAAQE,KAExC,GADAO,QAAQC,IAAI,kBAAmBV,EAAQE,IAAKD,IACvCA,EACH,OAAO,IAAIU,SAAS,KAAM,CACxBC,OAAQ,IACRC,WAAY,cAIhB,IAAIC,EAAUnB,EAAQoB,IAAId,IAAWa,QAGrC,IAAKA,EAAS,CAEZ,IAAIE,EACAC,EAFJR,QAAQC,IAAI,0BAGZI,EAAU,IAAII,SAAc,CAACC,EAAGC,KAC9BJ,EAAUG,EACVF,EAASG,KAGXzB,EAAQ0B,IAAIpB,EAAU,CACpBe,QAAS,KACPP,QAAQC,IAAI,WACZf,EAAQ2B,OAAOrB,GACfe,KAEFC,OAASM,IACPd,QAAQC,IAAI,UACZf,EAAQ2B,OAAOrB,GACfgB,EAAOM,IAETT,YAGF,IAAIU,QAAeC,OAAOC,MAAM3B,EAAGC,SACnC,GAAIwB,EAGF,OAFAf,QAAQC,IAAI,qBACZM,IACOQ,EACF,CACLf,QAAQC,IAAI,yBACZ,MAAMiB,QAAUlC,EAAGmC,QAAQb,IAAIhB,EAAG8B,UAC7BF,GAGHlB,QAAQC,IAAI,gCACZiB,EAAEG,YAAY,CAAEC,GAAI9B,KAHpBgB,EAAQ,0BAUd,aAFgBH,EAAQkB,MAAK,IAAMP,OAAOC,MAAM3B,EAAGC,WAAUiC,OAAOV,GAAQ,IAAIZ,SAASY,EAAK,CAAEX,OAAQ,IAAKC,WAAY,sBAIvH,IAAIF,SAAS,KAAM,CACjBC,OAAQ,IACRC,WAAY,cAnGlBpB,EAAGyC,iBAAiB,WAAYnC,IAC9BU,QAAQC,IAAI,iBAGdjB,EAAGyC,iBAAiB,WAAYnC,IAC9BA,EAAGoC,UACD,WACE,IAAIC,EAAOrC,EAAGqC,KACd,OAAQA,EAAKC,MACX,IAAK,QACH1C,EAAQoB,IAAIqB,EAAKL,KAAKf,UACtB,MACF,IAAK,WACHrB,EAAQoB,IAAIqB,EAAKL,KAAKd,OAAOmB,EAAKE,SAPxC,OAaJ7C,EAAGyC,iBAAiB,YAAanC,IAC/BU,QAAQC,IAAI,YACZX,EAAGoC,UACD,iBACgBV,OAAOc,KAAK,mBACpB9C,EAAGmC,QAAQY,QACjB/B,QAAQC,IAAI,oBAHd,OAkFJjB,EAAGyC,iBAAiB,SAAUnC,IAE5B,IADU,IAAIK,IAAIL,EAAGC,QAAQE,KACpBG,SAASoC,WAAW,eAC3B,OAAO,EAET1C,EAAG2C,YACD,WACEjC,QAAQC,IAAIX,EAAGC,QAAQ2C,SACvBlC,QAAQC,IAAI,cACLZ,EAAeC,IAHxB"}